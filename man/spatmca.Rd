% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/SpatMCA.R
\name{spatmca}
\alias{spatmca}
\title{Regularized spatial MCA}
\usage{
spatmca(
  x1,
  x2,
  Y1,
  Y2,
  M = 5,
  K = NULL,
  doesSelectRank = ifelse(is.null(K), TRUE, FALSE),
  tau1u = NULL,
  tau2u = NULL,
  tau1v = NULL,
  tau2v = NULL,
  x1New = NULL,
  x2New = NULL,
  center = TRUE,
  plot.cv = FALSE,
  maxit = 100,
  thr = 1e-04,
  doesSelectAllTuningParameters = FALSE,
  numCores = NULL
)
}
\arguments{
\item{x1}{Location matrix (\eqn{p \times d}) correponding to Y1. Each row is a location. \eqn{d=1,2} is the dimension of locations.}

\item{x2}{Location matrix (\eqn{q \times d}) correponding to Y2. Each row is a location.}

\item{Y1}{Data matrix (\eqn{n \times p}) of the first variable stores the values at \eqn{p} locations with sample size \eqn{n}.}

\item{Y2}{Data matrix (\eqn{n \times q}) of the second variable stores the values at \eqn{q} locations with sample size \eqn{n}.}

\item{M}{Optional number of folds; default is 5.}

\item{K}{Optional user-supplied number of coupled patterns; default is NULL. If K is NULL or doesSelectRank is TRUE, K is selected automatically.}

\item{doesSelectRank}{If TRUE, K is selected automatically; otherwise, doesSelectRank is set to be user-supplied K. Default depends on user-supplied K.}

\item{tau1u}{Optional user-supplied numeric vector of a nonnegative smoothness parameter sequence correponding to Y1. If NULL, 10 tau1u values in a range are used.}

\item{tau2u}{Optional user-supplied numeric vector of a nonnegative smoothness parameter sequence correponding to Y1. If NULL, 10 tau2u values in a range are used.}

\item{tau1v}{Optional user-supplied numeric vector of a nonnegative smoothness parameter sequence correponding to Y2. If NULL, 10 tau1v values in a range are used.}

\item{tau2v}{Optional user-supplied numeric vector of a nonnegative smoothness parameter sequence correponding to Y2. If NULL, 10 tau2v values in a range are used.}

\item{center}{If TRUE, center the columns of Y. Default is FALSE.}

\item{plot.cv}{If TRUE, plot the cv values. Default is FALSE.}

\item{maxit}{Maximum number of iterations. Default value is 100.}

\item{thr}{Threshold for convergence. Default value is \eqn{10^{-4}}.}

\item{doesSelectAllTuningParameters}{If TRUE, The K-fold CV performs to select 4 tuning parameters simultaneously. Default value is FALSE.}

\item{numCores}{Number of cores used to parallel computing. Default value is NULL (See \code{RcppParallel::defaultNumThreads()})}

\item{x1new}{New location matrix correponding to Y1. If NULL, it is x1.}

\item{x2new}{New location matrix correponding to Y2. If NULL, it is x2.}
}
\value{
A list of objects including
\item{Uestfn}{Estimated patterns for Y1 at the new locations, x1New.}
\item{Vestfn}{Estimated patterns for Y2 at the new locations, x2New.}
\item{Dest}{Estimated singular values.}
\item{crosscov}{Estimated cross-covariance matrix between Y1 and Y2.}
\item{stau1u}{Selected tau1u.}
\item{stau2u}{Selected tau2u.}
\item{stau1v}{Selected tau1v.}
\item{stau2v}{Selected tau2v.}
\item{cv1}{cv socres for tau1u and tau1v when doesSelectAllTuningParameters is FALSE.}
\item{cv2}{cv socres for tau2u and tau2v when doesSelectAllTuningParameters is FALSE.}
\item{cvall}{cv socres for tau1u, tau2u, tau1v and tau2v when doesSelectAllTuningParameters is TRUE.}
\item{tau1u}{Sequence of tau1u-values used in the process.}
\item{tau2u}{Sequence of tau2u-values used in the process.}
\item{tau1v}{Sequence of tau1v-values used in the process.}
\item{tau2v}{Sequence of tau2v-values used in the process.}
}
\description{
Produce spatial coupled patterns at the designated locations according to the specified tuning parameters or the tuning parameters selected by M-fold cross-validation.
}
\details{
The optimization problem is
\deqn{\max_{\mathbf{U}, \mathbf{V}} \frac{1}{n}\mbox{tr}(\mathbf{U}'\mathbf{Y}'_1\mathbf{Y}_2\mathbf{V}) - \tau_{1u}\mbox{tr}(\mathbf{U}'\mathbf{\Omega}_1\mathbf{U}) - \tau_{2u}\sum_{k=1}^K\sum_{j=1}^{p} |u_{jk}|- \tau_{1v}\mbox{tr}(\mathbf{V}'\mathbf{\Omega}_2\mathbf{V})-\tau_{2v}\sum_{k=1}^K\sum_{j=1}^{q} |v_{jk}|,}
\eqn{\mbox{subject to $ \mathbf{U}'\mathbf{U}=\mathbf{V}'\mathbf{V}=\mathbf{I}_K$,}} where \eqn{\mathbf{Y}_1} and \eqn{\mathbf{Y}_2} are two data matrices, \eqn{{\mathbf{\Omega}}_1} and \eqn{{\mathbf{\Omega}}_2} are two smoothness matrix, \eqn{\mathbf{V}=\{v_{jk}\}}, and \eqn{\mathbf{U}=\{u_{jk}\}}.
}
\examples{
###### 1D: regular locations
x_1D <- as.matrix(seq(-5, 5, length = 50))
Phi_1D <- exp(-x_1D^2) / norm(exp(-x_1D^2), "F")
set.seed(1234)
Y_1D <- rnorm(n = 100, sd = 3) \%*\% t(Phi_1D) + matrix(rnorm(n = 100 * 50), 100, 50)
cv_1D <- spatpca(x = x_1D, Y = Y_1D, numCores = 2)
plot(x_1D, cv_1D$eigenfn[, 1], type = "l", main = "1st eigenfunction")
lines(x_1D, svd(Y_1D)$v[, 1], col = "red")
legend("topleft", c("SpatPCA", "PCA"), lty = 1:1, col = 1:2)

\dontrun{
  ### 1D: artificial irregular locations
  rm_loc <- sample(1:50, 20)
  x_1Drm <- x_1D[-rm_loc]
  Y_1Drm <- Y_1D[,-rm_loc]
  x_1Dnew <- as.matrix(seq(-5, 5, length = 100))
  cv_1D <- spatpca(x = x_1Drm, Y = Y_1Drm, tau2 = 1:100, x_new = x_1Dnew)
  plot(x_1Dnew, cv_1D$eigenfn, type = "l", main = "eigenfunction")
  plot(cv_1D$Yhat[, 50], xlab = "n", ylab = "Yhat", type = "l", 
       main = paste("prediction at x = ", x_1Dnew[50]))
  ###### 2D: Daily 8-hour ozone averages for sites in the Midwest (USA)
  library(fields)
  library(pracma)
  data(ozone2)
  x <- ozone2$lon.lat
  Y <- ozone2$y
  date <- as.Date(ozone2$date, format = "\%y\%m\%d")
  rmna <- !colSums(is.na(Y))
  YY <- matrix(Y[, rmna], nrow = nrow(Y))
  YY <- detrend(YY, "linear")
  xx <- x[rmna, ]
  cv <- spatpca(x = xx, Y = YY)
  quilt.plot(xx, cv$eigenfn[,1])
  map("state", xlim = range(xx[, 1]), ylim = range(xx[, 2]), add = T)
  map.text("state", xlim = range(xx[, 1]), ylim = range(xx[, 2]), cex = 2, add = T)
  plot(date, YY \%*\% cv$eigenfn[,1], type = "l", ylab = "1st Principal Component")
  ### new loactions
  new_p = 200
  x_lon <- seq(min(xx[, 1]), max(xx[, 1]), length = new_p)
  x_lat <- seq(min(xx[, 2]), max(xx[, 2]), length = new_p)
  xx_new <- as.matrix(expand.grid(x = x_lon, y = x_lat))
  eof <- spatpca(x = xx, Y = YY, K = cv$Khat, tau1 = cv$stau1, tau2 = cv$stau2, x_new = xx_new)
  quilt.plot(xx_new, eof$eigenfn[,1], nx = new_p, ny = new_p, xlab = "lon.", ylab = "lat.")
  map("state", xlim = range(x_lon), ylim = range(x_lat), add = T)
  map.text("state", xlim = range(x_lon), ylim = range(x_lat), cex = 2, add = T)
  ###### 3D: regular locations
  x <- y <- z <- as.matrix(seq(-5, 5, length = 10))
  d <- expand.grid(x, y, z)
  Phi_3D <- exp(-d[, 1]^2 - d[, 2]^2 - d[, 3]^2) / norm(exp(-d[, 1]^2 - d[, 2]^2 - d[, 3]^2), "F")
  Y_3D <- rnorm(n = 1000, sd = 3) \%*\% t(Phi) + matrix(rnorm(n = 100 * 10^3), 100, 10^3)
  cv_3D <- spatpca(x = d, Y = Y_3D, tau2 = seq(0, 1000, length = 10))
  library(plot3D)
  library(RColorBrewer)
  cols <- colorRampPalette(brewer.pal(9, "Blues"))(10)
  isosurf3D(x, y, z, colvar = array(cv_3D$eigenfn[, 1], c(p, p, p)),
            level= seq(min(cv_3D$eigenfn[, 1]), max(cv_3D$eigenfn[, 1]), length = 10),
            ticktype = "detailed",
            colkey = list(side = 1),
            col = cols)
}
}
\references{
Wang, W.-T. and Huang, H.-C. (2017). Regularized principal component analysis for spatial data. \emph{Journal of Computational and Graphical Statistics} \bold{26} 14-25.
}
\author{
Wen-Ting Wang and Hsin-Cheng Huang
}
